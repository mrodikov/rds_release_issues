## Дано

* A, B и C - проекты, причём B и C являются дочерними в отношении A.
* T1, T2, ... , Tn - релизы 
* Релизы могут состоять из различных наборов проектов, так B и C могут быть отдельными релизами, 
а A всегда релизится с B и C. Обозначаем релизы конкретных проектов кодами T1A, T2B, T3C и т.д.

* Есть набор релизов:
```
T1A T1B T1C
    T2B
        T3C
T4A T4B T4C
```

![](https://github.com/mrodikov/rds_release_issues/blob/master/images/T1T2T3T4_set1.png)
## Ситуация 1 - Ручной revert T4 (без ошибок)
Активный релиз - `T4`

Откатываем релиз `T4`, получаем релиз `T1A T2B T3C`. 
Валидный ли это релиз? 
Наверное да, поскольку он существовал в таком виде когда мы после общего релиза T1 сделали T2 и T3 
для отдельных проектов и оно работало.

![](https://github.com/mrodikov/rds_release_issues/blob/master/images/T4A_reverted_set1.png)

## Ситуация 2 - Ручная активация T3C (без ошибок)
Активный релиз - `T4`

Активируем релиз `T3`,  получаем релиз `T4A T4B T3C`.
Уже не очень уверен, что это стабильный релиз, потому что гарантии что T4 совместим с T3C никто не давал.

Мы можем сделать ручной revert T3C до T4C, что правильно (восстанавливаем стабильное состояние).

![](https://github.com/mrodikov/rds_release_issues/blob/master/images/T3C_activated_set1.png)

## Ситуация 3 - Ручной revert релиза T4 (падающая активация T3C)
Активный релиз - `T4`

Откатываем релиз `T4`, получаем релиз `T1A T2B T4C`.
Тут уже точно всё сломали. T4C пытался откатиться до T3C, не смог и откатился до "предыдущей" версии - T4C.
Формально по коду это правильно, но фактически у нас сломанный релиз.
И ещё мы имеем возможность откатить "T2B" до T4B, чтобы получить ещё один сломанный релиз `T1A T4B T4C`.
Но не имеем возможности активировать релиз T4 целиком, потому как "Waiting for children"

![](https://github.com/mrodikov/rds_release_issues/blob/master/images/T4A_reverted_T3C_failed_set1.png)

## Ситуация 4 - (падающая активация T4C)
Активный релиз `T1A T2B T3C`

Активируем релиз T4, получаем релиз `T1A T1B T1C` и две проблемы:
1) Это уже неправильно, потому что активный релиз был `T1A T2B T3C`, то есть мы откатились больше чем стоило.
2) Если мы сделаем ручной откат Т1A, то rds попытается откатить релиз следующим образом:
```
T1A -> T4A
T1B -> T2B
T1C -> T3C
```

![](https://github.com/mrodikov/rds_release_issues/blob/master/images/T1AT2BT3C_to_T4_fail_set1.png)

Проблема в том, что составные части релиза T4 не знают друг о друге и выкладываются по сути независимо, 
то есть на момент времени когда часть релиза T4C зафейлилась у нас уже успешно выложились T4A и T4B 
со всеми вытекающими изменениями в БД.

На текущий момент времени мне кажется, что проблема фундаментальная, это изъян именно flow работы с "составными" релизами.
Не вижу вариантов как её решить малой кровью.
